#(def list (fn (& args) args))

list [fn (& args) args]: ;

map [f ary]:
	(.map ary & f)
;

concat [& args]:
	(.reduce args [] "+")
;

#(def defmacro (macro (name args & forms)
#		     `(def ~name ~(apply macro args forms))))

defmacro [macro [name args & forms]]:
	`(def ~name ~(apply macro args forms))
;

reduce [f ary]:
	(.reduce ary & f)
;

(defmacro import (& classes)
  `(do ~@(map (fn (class)
		  `(def ~class (:: ~class)))
	      classes)))

(import Kernel Object Module Class Range String Array)

require [name]:
	(.require Kernel name)
;

(defmacro comment (& forms))

(defmacro .. (obj form & more)
  (if (.empty? more)
    `(. ~obj ~form)
    `(.. (. ~obj ~form) ~@more)))

range [min max]:
	(.new Range min max)
;

(defmacro loop (& body)
  `(.loop Kernel & (fn () ~@body)))

str [& args]:
	(.join args)
;

not [x]:
	(.!@ x)
;

(defmacro when (condition & body)
  `(if ~condition (do ~@body) nil))

(defmacro when-not (condition & body)
  `(if ~condition nil (do ~@body)))

print [& args]:
	(.print Kernel (.join args " "))
;

println [& args]:
	(apply print args)
	(print "\n")
;

pr [& args]:
  (apply print (map [arg]:
                    	(.inspect arg))
                    	args
                    ;)
;

prn [& args]:
  (apply pr args)
  (print "\n")
;

each [f ary]:
  (.each ary & f)
;

+ [& args]:
	(.reduce args 0 "+")
;

* [& args]:
	(.reduce args 1 "*")
;

